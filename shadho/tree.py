"""Nodes for a search tree.
"""

from .spaces import BaseSpace

import json
import os
import weakref
import uuid

import numpy as np
import pandas as pd
import sklearn
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF


class ChildIsNotTreeNode(Exception):
    pass


class SearchTree(object):
    """Container for search trees and their metrics.

    Parameters
    ----------
    root : shadho.tree.SearchTreeNode
        The root node of the search tree.
    values : list(builtin type)
        Values and results generated by the search.
    priority : float
        The relative importance of searching this tree.

    """

    def __init__(self, root=None, values=None, priority=1.0):
        self.id = str(uuid.uuid4())
        self.set_root(root)
        self.values = values if values is not None else {}
        self.results = []
        self.priority = priority
        self.rank = 1
        self.assignments = {}
        self.min = None

    def set_root(self, root):
        """Set the root node of the tree.

        This function also calculates/sets the complexity of the tree.
        """
        if isinstance(root, SearchTreeNode):
            self.root = root
            self.complexity = self.root.complexity()
        elif isinstance(root, SearchTreeLeaf):
            self.root = SearchTreeNode('root', children=[root])
            self.complexity = self.root.complexity()
        else:
            self.root = None
            self.complexity = -1.0

    def add_result(self, param, result, update_priority=True):
        """Add a result to the tree.

        Records results to the tree and updates priority if necessary.

        Parameters
        ----------
        param : dict
            The hyperparameter values associate with this result.
        result : dict
            The results to record.
        update_priority : {True, False}
            Whether or not to update the priority.
        """
        p = self.flatten_param(param)
        p['loss'] = result['loss']
        for key in p:
            if key in self.values:
                self.values[key].append(p[key])
            else:
                self.values[key] = [p[key]]
        result['priority'] = self.priority
        self.results.append(result)
        if self.min is None or result['loss'] < self.min['loss']:
            self.min = result
        self.write()
        if update_priority and len(self.values['loss']) % 10 == 0:
            self.update_priority()


    def update_priority(self):
        """Update the priority approximation for this tree.

        This function implements Algotihm 2 from REFERENCE.

        Parameters
        ----------
        None

        Returns
        -------
        None
        """
        # Set up values into an array, transforiming non-numeric values to
        # categorical.
        vals = np.array([val if not isinstance(val[0], str)
                         else pd.factorize(val)[0]
                         for key, val in self.values.items()
                         if key != 'loss']).transpose()

        # Obtain the labels for learning the priority
        labels = np.array(self.values['loss'])
        train_len = int(np.ceil(len(labels) * .8))
        len_scales = []

        # Train a Gaussian Process 50 times and get the learned length scales
        for i in range(50):
            idx = np.random.permutation(np.arange(len(labels)))
            ls = np.random.uniform(low=0.1, high=2.0)
            kernel = RBF(length_scale=ls)
            gp = GaussianProcessRegressor(kernel=kernel, normalize_y=True)
            gp.fit(vals[idx[:train_len]],
                   labels[idx[:train_len]].reshape(-1, 1))
            len_scales.append(1.0 / gp.kernel.theta[0])

        # The priority is the magnitude of length scales learned.
        self.priority = np.linalg.norm(np.max(len_scales) - np.min(len_scales))

    def flatten_param(self, param):
        """Flatten a nested dictionary.

        Parameters
        ----------
        param : dict
            The dictionary, possibly nested, to flatten.

        Returns
        -------
        flat : dict
            `param` flattened to contain no nested dictionaries.
        """
        flat = {}
        for key in param:
            if isinstance(param[key], dict):
                x = self.flatten(param[key])
                for k in x:
                    f_key = '_'.join([key, k])
                    flat[f_key] = x[k]
            else:
                flat[key] = param[key]
        return flat

    def generate(self):
        """Generate a set of values from this tree.
        """
        return self.root.generate()

    def write(self):
        """Write this tree and its results to file.
        """
        spec = self.root.to_spec()
        out = {
                'spec': spec,
                'results': self.results
              }
        with open(''.join([self.id, '.json']), 'w') as f:
            json.dump(out, f)

    def clear_assignments(self):
        """Remove all compute class assignments from this tree.
        """
        self.assignments = {}

    def assign(self, assignment):
        """Assign this tree to a compute class.
        """
        self.assignments[assignment.name] = weakref.ref(assignment)

    def __gt__(self, other):
        return self.priority * self.complexity > \
                other.priority * other.complexity

    def __lt__(self, other):
        return self.priority * self.complexity < \
                other.priority * other.complexity

    def __eq__(self, other):
        return self.root == other.root


class SearchTreeNode(object):
    """Interior n-ary tree nodes.

    This class allows the construction of a hierarchical search space. Nodes in
    the tree may be optional (i.e. use the subtree or don't) or exclusive (i.e.
    follow only one child subtree at a time).

    Defines methods for generating values from the tree and for splitting the
    tree into a forest of search trees.

    Parameters
    ----------
    name : str
        The name of the node. Does not need to be unique: each node is known by
        its place in the hierarchy.
    children : list(shadho.tree.SearchTreeNode or shadho.tree.SearchTreeLeaf)
        References to child nodes that should be accessed from this node. May
        be empty
    exclusive : bool
        Whether to only follow one child (True) or all children (False)when
        searching child subtrees.
    optional : bool
        Whether the subtree rooted at this node is required to search.

    """

    def __init__(self, name, children=None, exclusive=False, optional=False):
        self.name = name
        self._complexity = 0
        self.children = []
        if children is not None:
            for child in children:
                self.add_child(child)
        self.exclusive = exclusive
        self.optional = optional

    def add_child(self, child):
        """Add a child to this tree node.

        Parameters
        ----------
        child : {shadho.tree.SearchTreeNode, shadho.tree.SearchTreeLeaf}
            The child node to add.

        Raises
        ------
        ChildIsNotTreeNode
        """
        if not isinstance(child, (SearchTreeLeaf, SearchTreeNode)):
            raise ChildIsNotTreeNode
        self.children.append(child)
        self._complexity += child.complexity()

    def generate(self):
        """Generate values from the subtree rooted at this node.

        This is a recursive process that generates values from a tree. Leaf
        nodes in the tree are stopping conditions for this process.

        Parameters
        ----------
        None

        Returns
        -------
        tree_val : dict
            The set of generated values from the subtree rooted at this node.

        See Also
        --------
        shadho.tree.SearchTreeLeaf.generate
        """
        tree_val = {}
        for child in self.children:
            try:
                tree_val[child.name] = child.generate()
            except ParameterError:
                continue
        return tree_val

    def split_spaces(self):
        """Split the search tree into distinct search spaces.

        Nodes in the search tree can be optional (i.e. subtree not included) or
        exclusive (i.e. only one branch taken at at time). In terms of the
        search, each optional or exclusive node represents a split point
        between two disjoint search spaces.

        To create a search forest, this method recursively generates all
        possible distinct search trees that exist in the tree. The
        resulting forest generated by this method contains the set of disjoint
        trees existing within the original search tree. If this method is run
        on one of the trees in the forest, it will return a copy of the tree.

        Returns
        -------
        spaces : list(dict)
            The list of distinct search trees that can be created by splitting
            this node and its subtrees on exclusive and optional nodes.
        """
        if len(self) == 0:
            return [self.copy()]
        spaces = [self.copy()] if not self.exclusive else []
        c = self.copy() if self.optional else None
        for child in self.children:
            subtree = child.split_spaces()

            # If we only need one subtree from the node at a time, make one
            # copy of this node for each child and assign a single child
            # to each copy.
            if self.exclusive:
                for i in subtree:
                    x = self.copy()
                    x.add_child(i)
                    spaces.append(x)

            # If we need all subtrees from this node, combine all subtrees of
            # all child nodes.
            else:
                newspaces = []
                for space in spaces:

                    # The inner loop accounts for exclusive child nodes.
                    for i in subtree:
                        x = space.copy(copy_children=True)
                        x.add_child(i)
                        newspaces.append(x)
                spaces = newspaces

        # If this node is optional, append a copy with no children
        if c is not None:
            spaces.append(c)
        return spaces

    def copy(self, copy_children=False):
        """Create a copy of this node with or without its children.

        When copying with children, this method returns a copy of the entire
        subtree rooted at this node.

        Parameters
        ----------
        copy_children : {False, True}, optional
            If False, copy only this node and not its children. Otherwise, copy
            the entire subtree rooted at this node.

        Returns
        -------
        copy : shadho.tree.SearchTreeNode
            A copy of the node with or without its children.
        """
        children = None if not copy_children \
            else [child.copy(copy_children=True) for child in self.children]
        return SearchTreeNode(self.name,
                              children=children,
                              exclusive=self.exclusive,
                              optional=self.optional)

    def complexity(self):
        """Determine the search complexity of the subtree rooted at this node.

        Complexity is recursively defined for a tree as the product of its leaf
        node complexities. This attempts to capture the combinatorics of the
        represented search spaces.

        Parameters
        ----------
        None

        Returns
        -------
        complexity : float
            The complexity of the subtree rooted at this node.

        See Also
        --------
        shadho.tree.SearchTreeLeaf.complexity
        """
        if self._complexity == 0 and len(self.children) > 0:
            self._complexity = np.prod([c.complexity() for c in self.children])
        return self._complexity

    def to_spec(self):
        """Convert this tree into its specification.

        Returns
        -------
        spec : dict
            The tree in its specification representation.
        """
        s = {}
        for c in self.children:
            s[c.name] = c.to_spec()
        return s

    def __str__(self):
        children = [str(c) for c in self.children] if len(self.children) > 0 \
                        else '{' + '}'
        return ' '.join([self.name + ': {', ', '.join(children), '}'])

    def __len__(self):
        return len(self.children)

    def __eq__(self, other):
        if not isinstance(other, SearchTreeNode):
            return False
        if self.name != other.name or self.exclusive != other.exclusive \
                or self.optional != other.optional:
            return False
        if len(self) == len(other):
            print("searching through children")
            flag = False
            for i in self.children:
                for j in other.children:
                    if i == j:
                        flag = True
                if not flag:
                    return False
            return True
        else:
            return False


class SearchTreeLeaf(object):
    """Values to generate during the search.

    Tree leaves represent the spaces that must be searched in the tree. These
    spaces can be continuous, discrete, or constant, and may be optional. If
    optional, the space will be a splitting point in the tree with one version
    searching the space and one version ignoring it.

    Parameters
    ----------
    name : str
        The name of the node. Does not need to be unique: each node is known by
        its place in the hierarchy.
    value : {None, shadho.tree.BaseSpace}, optional
        The search space in this node.
    exclusive : {False, True}, optional
        Whether to perform exhaustive search on discrete spaces. Ignored when
        the leaf contains a continuous space.
    optional : {False, True}, optional
        Whether this leaf node may be ignored.

    """

    def __init__(self, name, value=None, exclusive=False, optional=False):
        self.name = name
        self.value = value if value is not None else BaseSpace()
        self.optional = optional

    def generate(self):
        return self.value.generate()

    def split_spaces(self):
        return [self.copy()] if not self.optional else [self.copy(), None]

    def copy(self, **kwargs):
        return SearchTreeLeaf(self.name,
                              value=self.value,
                              optional=self.optional)

    def complexity(self):
        return self.value.complexity()

    def to_spec(self):
        return self.value.to_spec()

    def __str__(self):
        return str(self.value)

    def __len__(self):
        return 1

    def __eq__(self, other):
        if not isinstance(other, SearchTreeLeaf):
            return False
        return self.name == other.name and \
            self.value == other.value and \
            self.optional == other.optional
